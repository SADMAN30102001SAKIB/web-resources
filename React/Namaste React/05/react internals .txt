* Initial Render Process:
JSX code gets transpiled by Babel into React.createElement() calls, which is a JavaScript object.
This JavaScript object is the virtual DOM tree, a lightweight in-memory representation of the actual DOM.
The root.render() method is used for the initial render. When you call root.render(<App />), React takes the virtual DOM tree generated by the App component and converts it into actual DOM nodes and inserting them into the DOM tree.
For subsequent updates, React's reconciliation process occurs before rerendering. React Core manages reconciler & React DOM/React Native manages renderer.

* Virtual DOM:
It is a lightweight copy of/representation of the real DOM.
It acts as a blueprint for the actual DOM elements in the browser.  It's faster to create and compare virtual DOM trees than manipulating the actual DOM directly.
The real DOM is a tree representation of the web page and each branch of the tree ends in a node containing object that programmers can modify using DOM APIs and the changes to the dom are fast because its tree-like structure. But after the changes, the updated element and its children have to be re-rendered to update the UI, where the painting of the UI is slow.
AngularJS is a popular JavaScript framework that uses real DOM. One of its limitations is that it can be slow when rendering complex pages.

* React Fiber:
The Fiber architecture is a reimplementation of Reactâ€™s core algorithm, introduced in React 16, which makes the rendering tasks efficient by enabling features like concurrency, scheduling, and incremental rendering.
While Fiber itself isn't a single algorithm, it's a specific design pattern that utilizes various algorithms and techniques internally during reconciliation.
An architecture is the high-level structure of a software system, kind of like a blueprint. It defines how components interact, how data flows, and how tasks are managed. The architecture includes both design principles and the actual implementation that supports these principles.
When we refer to the "Fiber architecture" as the core of React, we're talking about the set of principles and techniques implemented within React's core that dictates how React performs re-rendering.
RECONCILIATION IS WHAT TO DO, FIBER IS HOW TO DO IT.

* Fiber Reconciliation Algorithm:
i) Incremental Rendering: Fiber splits the rendering work into units of work (fiber nodes) that can be paused and resumed, allowing React to update the UI incrementally. This allows React to manage updates in chunks rather than all at once. This avoids blocking the main thread.
ii) Priority Scheduling: The fiber reconciler uses a scheduling algorithm to prioritize updates based on their importance. This ensures high-priority updates (like user interactions) are processed before low-priority updates (like background data fetching).
iii) Concurrency: Enables React to work on multiple tasks at the same time, which maintains a responsive user interface.

* Fiber Tree:
The term "Fiber" refers to both the architecture and the internal data structure (Fiber tree and Fiber nodes).
The entire virtual DOM tree, represented by fiber nodes, is sometimes referred to as the Fiber tree, which is a specific representation of the entire application's virtual DOM. 
When a React component is first rendered, a virtual DOM tree is created. This virtual DOM tree is then used to construct the initial Fiber tree, but it includes additional information necessary for React to manage the rendering process via incremental rendering, scheduling updates, etc...

* Fiber Nodes:
Each element or component in the virtual DOM tree corresponds to a fiber node.
They are the smallest units of work in React Fiber that React can process incrementally. Each fiber node corresponds to a React component or element.
Each Fiber node represents a potential unit of work but React only processes the nodes that need updating.
Fiber nodes are implemented as JavaScript objects that hold various properties related to the component they represent. Like it's state, props, effects, a reference to its parent fiber, its children fibers, and its associated DOM node.

Reconciliation Process:
* State Change:
When the state, props of a component changes, React triggers the reconciliation process. This can happen due to user interactions, asynchronous data fetches, or other events.
This is the process of determining what changes need to be made. It includes the creation of the new virtual DOM, the diffing algorithm to compare the new and old virtual DOM trees, and the scheduling of updates.
In real-life scenarios, reconciliation refers to the process of bringing things back into harmony or agreement after a disagreement.
In React, reconciliation is the process diffing the virtual DOM tree with the updated virtual DOM to determine the most efficient way to update the real DOM. This process minimizes repaints in the browser.
This process, managed by the Fiber architecture, is designed to be asynchronous. This means it can be paused, resumed, and interrupted, allowing React to manage updates efficiently and ensure high-priority tasks are handled promptly.
Reconciliation is the core mechanism in React that ensures the data layer and UI layer remain synchronized.

* Diffing Algorithm:
The diffing algorithm compares the new virtual DOM tree with the old one to identify the minimal set of changes (additions, deletions, updates) required to transform the old tree into the new tree. This comparison is efficient and typically operates in O(n) time, where n is the number of nodes.
How It Works:
If the root elements have different types, React will tear down the old tree and build the new tree from scratch.
For elements of the same type, React looks at the attributes and updates only the changed attributes.
React recursively steps down the tree and compares the children of the nodes.

How React Applies Changes:
* React Fiber and Scheduling:
Once the diffing process identifies the changes, React prepares to apply these changes to the actual DOM. This preparation still occurs within the context of the Fiber tree.
Fiber tree helps breaking down the rendering work into smaller units of work which can be processed incrementally, but the actual DOM manipulation is done using standard DOM APIs
Fiber nodes are processed in a way that high-priority updates (like user interactions) are handled before lower-priority updates.

* Commit Phase: This phase is part of the rendering process, where the changes identified during reconciliation React applies the changes to the real DOM in a batch, ensuring minimal performance impact.
Batching is a performance optimization technique where multiple state updates triggered by user interactions or other events are combined into a single group/batch. React processes the batch, calculates the minimal set of changes needed to update the virtual DOM, and schedules these changes. 
The changes from the batch are applied to the real DOM in one go minimizing the number of DOM updates and improving the overall performance of the application.
The actual application of changes to the DOM are managed by ReactDOM. This phase is synchronous and blocks the main thread until all changes are applied.

Complete Example with Clear Steps:
i) Initial Render:
function App() {
  const [count, setCount] = React.useState(0);
  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
ii) After Transpilation:
{
  type: 'div',
  props: {},
  children: [
    { type: 'h1', props: {}, children: ['Count: 0'] },
    { type: 'button', props: { onClick: [Function] }, children: ['Click me'] }
  ]
}
iii)Fiber Node Structure (simplified):
FiberNode {
  type: 'div',
  props: {},
  child: FiberNode {
    type: 'h1',
    props: {},
    child: ['Count: 0'],
    sibling: FiberNode {
      type: 'button',
      props: { onClick: [Function] },
      child: ['Click me']
    }
  }
}
iv) root.render():
Converts the virtual DOM tree into actual DOM nodes and inserts them into the DOM.
v) State Change:
User clicks the button, updating the state: setCount(count + 1).
vi) Reconciliation:
New virtual DOM tree is created:
{
  type: 'div',
  props: {},
  children: [
    { type: 'h1', props: {}, children: ['Hello, world!'] },
    { type: 'button', props: { onClick: [Function] }, children: ['Click me'] },
    { type: 'p', props: {}, children: ['Count: 1'] }
  ]
}
vii) So, with the new VDOM, a new Fiber Tree is created.
viii) Diffing Algorithm:
Compares the new and old virtual DOM trees, identifying the change in the <h1> element's text.
ix) Fiber tree helps breaking down the rendering work into smaller units of work which can be processed incrementally, but the actual DOM manipulation is done using standard DOM APIs.
x) Commit Phase:
The identified change (updating the <h1> element's text) is applied to the actual DOM.

Before Fiber reconciler, React used a Stack Reconciler. 
The stack-based reconciler operated on a single call stack. This means it handled the entire rendering and reconciliation process in one continuous flow, without interruption. 
In Stack Reconciliation, the process ran synchronously from start to finish, blocking the main thread. The synchronous nature meant that large updates could block the main thread, leading to unresponsive UI.
The main difference between the fiber reconciler and the stack reconciler is that the fiber reconciler breaks down the reconciliation process into smaller chunks called fibers.
These fibers can be executed independently and prioritized based on their importance.